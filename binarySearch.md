# Бинарный поиск #

Бинарный поиск следует методологии разделяй и властвуй . Это быстрее, чем линейный поиск, но требует, чтобы массив был отсортирован до выполнения алгоритма.

## Алгоритм ##

Предполагая, что мы ищем значение val в отсортированном массиве, алгоритм сравнивает val со значением среднего элемента массива, который мы будем называть mid .

- Если mid – это элемент, который мы ищем (в лучшем случае), мы возвращаем его индекс.

- Если нет, то мы определяем , на какой стороне mid | vail с большей вероятностью будет находиться val , основываясь на том, меньше или больше mid , и отбрасываем другую сторону массива. Затем мы рекурсивно или итеративно выполняем те же шаги, выбирая новое значение для

- mid , сравнивая его с val и отбрасывая половину возможных совпадений на каждой итерации алгоритма.
Алгоритм бинарного поиска может быть записан рекурсивно или итеративно.

Рекурсия обычно медленнее в Python , потому что она требует выделения новых кадров стека.

## Реализация ##

Поскольку хороший алгоритм поиска должен быть максимально быстрым и точным, давайте рассмотрим итеративную реализацию бинарного поиска:

```python
def BinarySearch(lys, val):
    first = 0
    last = len(lys)-1
    index = -1
    while (first <= last) and (index == -1):
        mid = (first+last)//2
        if lys[mid] == val:
            index = mid
        else:
            if val
```

Итак, если мы используем функцию для вычисления:

```python
BinarySearch([10,20,30,40,50], 20)
```

После выполнения кода нас встречают:

```python
1
```

Это индекс первого вхождения элемента, который мы ищем, имея в виду, что индексы Python основаны на 0.

Действие, которое алгоритм выполняет следующим в каждой итерации, является одной из нескольких возможностей:

- Возврат индекса текущего элемента
- Поиск по левой половине массива
- Поиск в правой половине массива

## Время сортировки ##

Мы можем выбрать только одну возможность на каждой итерации, и наш пул возможных совпадений делится на две в каждой итерации. Это делает временную сложность бинарного поиска O(log n) .
