# Поиск прыжка #

Jump Search похож на бинарный поиск в том, что он работает с отсортированным массивом и использует аналогичный подход divide and conquer для поиска по нему.

Его можно классифицировать как усовершенствование алгоритма линейного поиска, поскольку он зависит от линейного поиска для выполнения фактического сравнения при поиске значения.

## Алгоритм ##

Учитывая сортированный массив, вместо того чтобы искать элементы массива постепенно, мы ищем в прыжках . Итак , в нашем входном списке list , если у нас есть размер прыжка jump , наш алгоритм будет рассматривать элементы в порядке lys[0] , lys[0+jump] , lys[0+2jump] , lys[0+3jump] и так далее.

С каждым прыжком мы сохраняем предыдущее значение, на которое смотрели, и его индекс. Когда мы находим набор значений , где lys[i] lys[i+jump] , мы выполняем линейный поиск с lys[i] в качестве самого левого элемента и lys[i+jump] в качестве самого правого элемента в нашем наборе поиска

## Реализация ##

Поскольку хороший алгоритм поиска должен быть максимально быстрым и точным, давайте рассмотрим итеративную реализацию бинарного поиска:

```python
import math

def JumpSearch (lys, val):
    length = len(lys)
    jump = int(math.sqrt(length))
    left, right = 0, 0
    while left < length and lys[left] <= val:
        right = min(length - 1, left + jump)
        if lys[left] <= val and lys[right] >= val:
            break
        left += jump;
    if left >= length or lys[left] > val:
        return -1
    right = min(length - 1, right)
    i = left
    while i <= right and lys[i] <= val:
        if lys[i] == val:
            return i
        i += 1
    return -1
```

Итак, если мы используем функцию для вычисления:

```python
BinarySearch([10,20,30,40,50], 20)
```

После выполнения кода нас встречают:

```python
1
```

## Время сортировки ##

Временная сложность поиска прыжка равна O(√n) , где √n – размер прыжка, а n – длина списка, помещая поиск прыжка между алгоритмами линейного поиска и бинарного поиска с точки зрения эффективности.
